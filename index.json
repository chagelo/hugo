[{"categories":null,"contents":"DAGAN paper: Deep De-Aliasing for Fast Compressive Sensing MRI\n  如上图，$x_u$文中说是 zero-filling undersampling k-space measurement 的重建，应该是加了噪声。文中实验给出了加上一维高斯噪声和二维高斯噪声的结果。$x_t$是完整测量重建的结果。这是对 mri 单通道重建的一个算法。\nCycle-MedGAN paper: Unsupervised Medical Image Translation Using Cycle-MedGAN\n关键部分在于对 CycleGAN 的 loss 的改动；\n  $$\\mathcal L_{cPercep} = \\sum_{i=0}^{L}\\lambda_{cp,i}(||F(x)-F_i(\\hat{\\hat{x}})||_1+||F(y)-F_i(\\hat{\\hat{y}})||_1)$$\n$$ Gr_i^{m,n}(x)=\\frac{1}{h_iw_id_i}\\sum_{h=1}^{h_i}\\sum_{w=1}^{w_i}F_i^{h,w,n}(x)F_i^{h,w,m}(x) $$\n$$ \\mathcal L_{cStyle}=\\sum_{i=1}^{L}\\lambda_{cs,i}\\frac{1}{4d_i^2}(||Gr_i(x)-Gr_i(\\hat{\\hat{x}})||_F^2+||Gr_i(y)-Gr_i(\\hat{\\hat{y}})||_F^2) $$\n","date":"2021-12-11T22:38:53+08:00","permalink":"https://chagelo.github.io/hugo/post/summary-of-dl-based-mri-artifacts-reduction-methods/","section":"post","tags":null,"title":"Summary of DL Based MRI Artifacts Reduction Methods"},{"categories":null,"contents":"abstract cyclegan 不可否认是一个很优秀的模型，然而它也有一个很大的缺陷，它要求 translation 必须可逆。aclgan 中提出了一个种 loss 解决这个问题，这里。\n本片文章中提出使用对比学习解决这个问题。他们使用一种基于 patch 的方法，而并非考虑对整张图片进行操作。这个方法考虑输入图片 patch 和生成输出图片对应位置 patch，希望两个关联的 patch 能够映射到学习到的 feature space 中的同一个点（通过对比学习）。\n作者验证了该方法对于单向的 translation 是优秀的，提高了图片并且减少了训练时间。\nintroduction 对于 image translation，它从一个 domain 转换到另一个 domain，我们想要它的结构和内容不改变，这是一个 disentanglement problem，输出图片通过对抗 loss 来约束，同时使用 cycle-consistency 来保留内容，然而它有个前提就是两个 domain 之间的转换是双射，这由具体的任务所决定，这个条件非常具有限制性，或者说很严格。\n这篇文章的方法很直接，来保持每一对输入输出 patch 内容的关联性，让他们所拥有的公共信息更多（比如形状，动物的纹理，或者说动物的外观，目标物）。他们通过训练一个 encoder 来实现，encoder 关注两个 domain 的共同点。\nIn this paper, we propose an alternative, rather straightforward way of maintaining correspondence in content but not appearance\n上面这句话是文中原话，值得思考的是什么叫做not appearance（每个 pixel 的 loss 相加，考虑整张图）。\n关于正负样本，从输入图片的其他位置取 patch 作为负样本，相比使用其他图片的 patch，能够使得结果 patch 更好的保留输入图片的内容。该方法不需要 memory bank 或者 特殊的结构（如 Data-efficient image recognition with CPC、AMDIM\n经作者所言，他们的模型快且轻量级，超越了两个 one-sided translation 模型（参见原文参考文献），以及一些依赖于几个 auxiliary 网络结构和很多个 loss 而达到 sota 的模型。\nrelated work  image translation and cycle-consistency；UNIT、MUNIT 二者学习一个比较清晰的中间 content latent space；一些工作也在关注于多 domain、多模态的合成，并且提高结果质量；cycle-consitency 被使用到很多场景，（a）两个 domain（b）图片到 latent（c）latent 到图片；基于 cycle-consistency 的重建比较困难，特别是当 input domain 相比 target domain 拥有更多信息的时候； relation preservation；有一些工作如 DistanceGAN、GcGAN 等绕过 cycle-consistency 实现单向的翻译。cycle-consistency 的目的就是不希望 input domain 到 target domain 的改变太多，也就是说它也希望尽可能保留 input domain 的内容；这里方法，在 input 和 output 之间学习一个跨 domain 相似性函数； Emergent perceptual similarity in deep network embeddings；衡量高维度的数据、信号之间的感知距离在图像处理计算机视觉中是一个一直一来的问题，image translation 一般使用 l1 来衡量每个像素，这会导致模糊，且不能反映人的感知。perceptual loss、feature loss、contextual loss。 Contrastive representation learning.  method 本文方法避免训练一个多余的 generator 和 discriminator。\n  这个 loss 是 InforNCE Loss； $G_{enc}$是 generator 的 encoder，它的输出就是输入图片的 feature 的 embedding，它将其中的 encoder 中的$L$层的 feature map 拿出来，将其输入到 mlp 中。\n除了整张图像具有内容上的共同特征，输出和输出每个对应 patch 也具有这样的对应关系。例如：给定一张斑马的腿部的图像 patch，则其转换前的马的图像也应当是包含对应的腿部的 patch，甚至在像素级别，斑马的颜色像素也应当是对应到马的颜色像素，而不是对应到背景草地的颜色像素，因此本文应用多层的基于 Patch 的 learning objective。\n  它们将 encoder 的中间结果 feature map 拿出来送入到 mlp 中（利用 mlp 进行sample 一些 patches），不同 feature map 对应不同 level 的信息，不同 patch 对应不同位置。它们用这些 patches 计算 loss。（对于生成的图片 patch 包含腿部，那么对应于输入肯定希望是也是腿部，不过是马纹理不同，比如输出 patch 包含马的身体，那么希望输入 patch 不包含比如填空）不同尺度，不同位置要对应的上，因此采用 mutilayer。\n  单张图片的内部的数据在分割、超分、降噪上都被证明是有效的。实验中也发现使用同一张图片的数据作为负样本，要好过使用数据集中其他图片采样作为负样本。\n  此外也考虑把数据集其他图片采样作为负样本计算 nce loss。作者还将 domainY 的图片输入 网络计算 PatchNCE Loss，这和 identity loss 很类似；\n  令$\\lambda_{X}=1,\\lambda_{Y}=1$，这种配置下的网络结构叫做 CUT，而$\\lambda_{X}=10,\\lambda_{Y}=0$叫做 FastCUT，前者的效果非常好，后者可以看作是一种快速且轻量级的 CycleGAN。\n作者也有一些失败的结果，比如对于一匹后腿直立的马，由于模型识别不出这种不熟悉的姿态，导致给背景也添加上了斑马纹理。另外对于猫到狗的例子，其中有个例子凭空多了舌头。\nExperiments Training details，主要和 CycleGAN做对比，所以实验设置和 CycleGAN 很类似。\n  上面的实验是 Cityscapes 数据集上的分割结果。可以看出结果比一些 baseline 要好。且速度和内存消耗比 CycleGAN 都要优秀\nAblation study and analysis 文中方法有很多细节，文中方法使用了 resnet-based generator（used in CycleGAN），patchnce 从输入图片采样负样本，以及从 generator 得到 encoder 提取 feature map，以及 identity loss.\n    在没有 identity loss，或仅使用 encoder 最后一层的 feature 作为 mlp 输入，或者只使用其他样本采样的负例，效果都不太行。\n  identity loss 相当于一个正则项，它一定程度保证稳定性，右边那个比较明显，导致了 collapse。\n作者还使用 momentum encoder 来从其他图片采样负样本，使用 external and internal 负样本，效果比只使用 internal 负样本效果差。 从上面的 Cityscape 的结果可以看到一些质量的相比的下降，会有一些重复的纹理，所以从与输出图片对应的输入图片采样负样本可能是有助于保留输入图片的 content。\n Internal negatives are more effective than external. Importance of using multiple layers of encoder identity loss regularizer stabilizes training. Visualizing learned similarity by encoder G_enc  code     conclusion 这篇文章提出一种方法用于解决 CycleGAN-consistency 的问题（translation 必须是双射）。所以对于 big object removal 或者 shape change 等，CycleGAN 做的不太行，本文方法一方面能够解决 CycleGAN 的问题，另一方面又能在总体上达到且超越 CycleGAN 的总体效果。\n通过使用对比学习，非常直接的考虑 input 和 output 在这个 translation 过程中必须保留内容（类似 SimCLR），而任务的令一方面 transaltion 则由 GAN 实现。相比而言它能够达到 CycleGAN 的效果，并且少训练一个 generator 和 discriminator，更加轻量级，这是它的优点。\n试验中也有一些失败的 case 比如对于后腿直立的马并不能很好的转换为斑马，一个原因是网络没有见过很多不同姿态的马，另一个就是 cat2dog 凭空多出了舌头（虽然人的直觉上是很好的，但这里的 translation 并不是好的），一个直觉就是 generator 和 contrastive learning 并没有 connect 的很好（比如它们 loss 的权重是不是能够调一下）。\nreference 待阅读参考文献\n1.One-sided unsupervised domain mapping. 2.Geometry- consistent generative adversarial networks for one-sided unsupervised domain map- ping 3.自监督系列：AMDIM、Moco、SimCLR、BYOL 4.UNIT 有待再完整的读一下（MUNIT）（VAE） 5.Augmented cyclegan: Learning many-to-many mappings from unpaired data 6.Harmonic unpaired image-to-image translation 7.TraVeLGAN、DistanceGAN、GcGAN（one-way translation）\n","date":"2021-11-28T21:05:35+08:00","permalink":"https://chagelo.github.io/hugo/post/contrastive-learning-for-unpaired-image-translation/","section":"post","tags":null,"title":"Contrastive Learning for Unpaired Image Translation"},{"categories":null,"contents":"下面的命令都可以用首字母代替；\nbreak n （简写b n）:在第n行处设置断点 break func：在函数func()的入口处设置断点，如：break cb_button delete n：删除第n个断点 info b （info breakpoints） ：显示当前程序的断点设置情况 delete breakpoints：清除所有断点： b *address在address处添加断点\n运行 run：简记为 r ，其作用是运行程序，当遇到断点后，程序会在断点处停止运行，等待用户输入下一步的命令。 continue （简写c ）：继续执行，到下一个断点处（或运行结束） next：（简写 n），单步跟踪程序，当遇到函数调用时，也不进入此函数体；此命令同 step 的主要区别是，step 遇到用户自定义的函数，将步进到函数中去运行，而 next 则直接调用函数，不会进入到函数体内。 step （简写s）：单步调试如果有函数调用，则进入函数；与命令n不同，n是不进入调用的函数的，需要有断点 查看代码和输出 list ：简记为 l ，其作用就是列出程序的源代码，默认每次显示10行。 list 行号：将显示当前文件以“行号”为中心的前后10行代码，如：list 12 list 函数名：将显示“函数名”所在函数的源代码，如：list main print 表达式：简记为 p ，其中“表达式”可以是任何当前正在被测试程序的有效表达式，比如当前正在调试C语言的程序，那么“表达式”可以是任何C语言的有效表达式，包括数字，变量甚至是函数调用。 print a：将显示整数 a 的值 print/x \u0026lt;my_var\u0026gt; 用16进制表示var i r rax: 表示rax寄存器的值 i r：表示所有寄存器的值 layout src：显示源代码窗口 layout asm：显示反汇编窗口 p 的使用比较复杂\n关于 p p 有很多可选参数；p/f表示指定格式输出，比如x表示以十六进制输出，o将整数以十进制输出的等等；Output-Formats\np/x *((int *)address)表示以十六进制输出整数，address是其存放地址；p/s (char *)address表示输出首地址在address的字符串；如果是结构体，类似；p/x *address，会以十六进制输出address位置的 4 个字节（i386）;\np/x *(int *)($esp+0x4)也是可行的；或者x/w $esp+0x4；How to print -0x4(%rbp) in gdb?\n上面的x/w中的x表示检查内存的意思，w和上面类似，Examining Memory\np *address@20访问数组的前20个元素，首地址是address\nreference  Debugging with GDB  ","date":"2021-11-17T23:35:49+08:00","permalink":"https://chagelo.github.io/hugo/post/gdb_debug/","section":"post","tags":null,"title":"Gdb_debug"},{"categories":null,"contents":"微习惯是什么 首先需要明确两个事实：\n 如果不行动，决心再大也无用； 研究表明：人总会习惯性高估自己的自控力；  并且：\n 哪怕是一点点行动，也比不作为好（至少数学上是，现实生活中也是； 相比一天做很多事，每天做一点的影响力更大。每天做一点就会形成习惯，久而久之，只要保持，习惯越不容易被打破；  《米哈尔科商业创意全攻略》（Thinkertoys, Michael Michalko）讲的是创造性思维以及如何解决问题。 如果想解决一个问题，那么可以从它的对立面着手思考，看看会有什么创意迸发出来。如果想盖一座摩天大楼，就反过来想如果造一座深入地下的建筑会怎么样。这样可以强迫大脑拓宽思维，看到更多的可能性，从而激发更多创意。\n只为好习惯 通过养成更多的好习惯来边缘化一些坏习惯。\n微习惯 微习惯因为太小而不至于无法完成，因此就不会有消极情绪，愧疚、挫败感。\n大脑的工作原理 大脑是我的一切,华生。身体只是附件而已。——阿瑟·柯南·道尔,《福尔摩斯探案集》\n首先需要明确“多重复几遍，就不会忘记”这样一个事实。\n建立习惯意味着改变，而大脑会抗拒改变（一般改变需要付出代价），除非给大脑一些回报。从大脑角度看，建立和改变习惯的两个关键是重复和回报。\n另外，当建立习惯后，大脑能迅速作出反应，比起有意识权衡、选择、行动，更加有效率。\n","date":"2021-11-13T23:45:46+08:00","permalink":"https://chagelo.github.io/hugo/post/microhabit/","section":"post","tags":null,"title":"Microhabit"},{"categories":null,"contents":"一些语法 x86-64 16个寄存器\n注意rax可以做函数返回值。\nAT\u0026amp;T格式汇编中，立即数表示为$跟一个C标准的整数，$-577或$0x1f\n$Imm(r_b, r_i, s)$表示的地址为$Imm+R[r_b]+R[r_i]\\cdot s$\n指令 x86-64 规定mov的两个操作数不能都指向内存，内存里面数据转移至少要两个指令。\nmovl以寄存器作为目的时，会把寄存器的高位4字节置为0。x86-64的惯例，任何为寄存器生成32位值的指令都会把该寄存器的高位部分置为0。\nmov指令的最后一个字符需要和寄存器相互匹配。\nrbp、ebp、bp、bpl不能作为目的地址寄存器。\nleaq\n加载有效地址，目的操作数必须是寄存器，可将将它看成mov\n128位乘除法\nimul有单操作数和双操作数的指令。\nclto, cqto都是对%rax进行操作，进行符号扩展。\n移位\n在x86-64中，移位量由%cl寄存器的低位决定，高位会忽略，比如对于salq移位量最大是63，%cl低6位决定。\n条件码\ncf: 最高位进位，检查无符号溢出 zf: 0标志 sf: 符号位，是不是负数 of: 是否溢出，正溢出或负溢出\ntest 和 cmp\ntest 使用两个操作数的与运算结果来测试，cmp 则是减法。注意它们的结果都是去设置条件码。\n注意cmpq %rsi, %rdi实际上比较的是%rdi和%rsi。\nset指令\nsetg和setnle实际上是相同指令。\n对于setl表示当小于时设置指令（根据上一步结果的条件码设置）。\n 若of为0，没有溢出；a - b \u0026lt; 0, a \u0026lt; b，有sf = 1，a - b \u0026gt;=0, a \u0026gt;= b，有sf = 0，sf ^ of = 0； 若of为1，a - b \u0026gt; 0（负溢出）, a \u0026lt; b，sf = 0, a - b \u0026lt; 0（正溢出）, a \u0026gt; b, sf = 1；  条件数据传送：计算一个条件操作中的两种结果，根据条件从其中取一个；和条件转移相比，这更像一种离线操作，后者更像在线操作。\n数据传送 若一个P调用Q，n个参数，n \u0026gt; 6，那么P的代码分配的栈帧必须能容纳7到n号参数的存储空间，如下图所示意；\n调用时先把1-6号参数复制到对应寄存器，之后其他参数放到栈中，7号在栈顶；调用时返回地址也被压入栈\n但是有的时候数据必须放在内存中，比如：\n 寄存器不足以存放所有本地数据 使用了\u0026amp;，就需要给它一个地址 数据，结构体  下面的一个例子很好。\n\u0026lt;img src=\u0026quot;/hugo/image/call_func.png\u0026gt;\n下面是一个更复杂的例子\nlong call_proc() { // long is regard as 8 bytes;  long x1 = 1; int x2 = 2; short x3 = 3; char x4 = 4; proc(x1, \u0026amp;x1, x2, \u0026amp;x2, x3, \u0026amp;x3, x4, \u0026amp;x4); return (x1 + x1) * (x3 - x4); } call_proc: ; set up arguments to proc subq $32, %rsp ;allocate 32byte stack frame movq $1, 24(%rsp) ;store 1 in \u0026amp;x1 movl $2, 20(%rsp) ;store 2 in \u0026amp;x2 movw $3, 18(%rsp) ;store 3 in \u0026amp;x3 movb $4, 17(%rsp) ;store 4 in \u0026amp;x4 leaq 17(%rsp), %rax ;create \u0026amp;x4 movq %rax, 8(%rsp) ;store \u0026amp;x4 as argument 8 movl $4, (%rsp) ;store 4 as argument 7 leaq 18(%rsp), %r9 ;pass \u0026amp;x3 as argumen 6 movl $3, %r8d ;pass 3 as argument 5 leaq 20(%rsp), %rcx ;pass \u0026amp;x2 as argument 4 movl $2, %edx ;pass 2 as argument 3 leaq 24(%rsp), %rsi ;pass \u0026amp;x1 as argument 2 movl $1, %edi ;pass a as argument 1 ; call proc call proc ; retrieve changes to memory movslq 20(%rsp), %rdx ;get x2 and convert to long addq 24(%rsp), %rdx ;compute x1 + x2 movswl 18(%rsp), %eax ;get x3 and convert to int movsbl 17(%rsp), %ecx ;get x4 and convert to int subl %ecx, %eax ;compute x3 - x4 cltq ;convert to long imul %rdx, %rax ;compute (x1 + x2) * (x3 - x4) addq $32, $rsp ;deallocate stack frame ret ;return 由于x1, x2, x3, x4都用到了地址，所以都分配了内存空间，对于函数调用，需要将前6个参数送到寄存器，除此6个参数外的两个参数需要在内存中分配空间，因此x4的地址也要存储，而不能想直接使用x4的地址。栈底的一部分参数（比如4个变量）我感觉是属于调用函数的栈帧，而后面靠近栈顶的是属于被调用函数proc的栈帧。\n被调用者保存寄存器\n寄存器%rbx、%rbp和%r12~%r15被看作是被调用者寄存器，当P调用Q时，Q必须保存这些寄存器的值，而Q要么一直不动这些寄存器，要么把这些值入栈。\n如果一个寄存器被标识为“Caller Save”， 那么在进行子函数调用前，就需要由调用者提前保存好这些寄存器的值，保存方法通常是把寄存器的值压入堆栈中，调用者保存完成后，在被调用者（子函数）中就可以随意覆盖这些寄存器的值了。如果一个寄存被标识为“Callee Save”，那么在函数调用时，调用者就不必保存这些寄存器的值而直接进行子函数调用，进入子函数后，子函数在覆盖这些寄存器之前，需要先保存这些寄存器的值，即这些寄存器的值是由被调用者来保存和恢复的。\n%rbp通常指示当前栈帧的起始位置\nlong P(long x, long y) { long u = P(x); long v = Q(y); return u + v; } ; x in %rdi, y in %rsi P: pushq %rbp ; save %rbp pushq %rbx ; save %rbx subq $8, %rsp ; align stack frame movq %rdi, %rbp ; save x movq %rsi, %rdi ; move y to first argument call Q ; call Q(y) movq %rax, %rbx ; save u = Q(y) movq %rbp, %rdi ; move x to first argument call Q ; call Q(x) addq %rdx, %rax ; u + v addq $8, %rsp ; deallocate last part of stack popq %rbx ; retore %rbx popq %rbp ; resore %rbp ret 前两条push保存之前被调用者寄存器到栈中（此时P是被调用者）；\ngcc 优化访问数组\n$$D[i][j] = x_D + L(C\\cdot i + j$$\n在访问元素的时候，访问地址，然后访问某个元素，假如编译器不作优化，那么访问一个数组的一行元素，没访问一次就需要拿行元素个数乘以元素大小，不考虑实际运算，也会耗费很多乘法操作，乘法貌似很昂贵？因此编译器优化会尽可能不使用额外的乘法运算。\n与 i386（32bit） 区别   i386 只有前 8 个寄存器，且只有 32 位；\n  参数传递：x86-64 基本使用寄存器传递参数，寄存器不够使用栈，i386 将参数放入栈中，第一个参数放在栈顶\n  在被调用函数内部，函数返回值前，\n 将返回值存到%eax 将栈顶置为未调用之前的状态（也就是恢复调用者的栈顶），movl %ebp, %esp 恢复调用者的栈底，popl %ebp ret返回  在函数内部，刚刚调用时\n 函数返回地址入栈 将%ebp入栈，也就是在调用函数的栈帧的底部地址入栈 可能会有将其他寄存器内容入栈，进行保护； 通过%esp分配局部变量；  i386 中 2、3 两部通过leave实现；\n ","date":"2021-11-11T22:23:34+08:00","permalink":"https://chagelo.github.io/hugo/post/program-in-machine-level/","section":"post","tags":null,"title":"Program in Machine Level"},{"categories":null,"contents":"manjaro下安装hugo 安装hugo sudo pacman -Sy hugo # 本地new一个存放hugo数据的文件夹，并进行初始化 hugo new site ~/hugo 主题 下载 cd hugo git init git submodule add https://github.com/heyeshuang/hugo-theme-tokiwa.git themes/hugo-theme-tokiwa 主题调整 cd hugo \u0026amp;\u0026amp; npm i \u0026amp;\u0026amp; npm start 使用 #在hugo/content创建post hugo new post/hugo-install.md ","date":"2021-09-10T21:25:17+08:00","permalink":"https://chagelo.github.io/hugo/post/hugo-install/","section":"post","tags":null,"title":"Hugo Install"},{"categories":["算法","数学"],"contents":"链接 $\\text{SPOJ - NO GCD}$\n题意  给你一个长度为$n$的序列$a$，并且对于任意一个数$a[i]$，它只有小于$50$的素因子，且不含有平方因子，求有多少对$(i,j)$，使得$a[i]和a[j]$互质，或者$gcd$是质数。\n 输入格式：第一行输入$t$，包含$t$组样例，下面每组样例第一行一个$n$，下面一行输入一个长度为$n$的序列$a$。\n 数据范围：$1\\leq t\\leq 10,1\\leq 100000$.\n 输出格式：每个样例对应一行一个输出结果。\n分析  这一题是偶然在别人博客看到的，几乎没怎么写过数学题，感到这个思路非常非常的巧妙。\n 首先考虑到了$50$以内的素数仅有$15$个，而对于$a$序列中的任意两个数来说，它们的$gcd$要么为$1$，要么在这$15$个素数之中，要么为$1$，如果用二进制表示，那么则有它们二进制表示的与的结果为$0$，或者某一位为$1$(恰好有一个素因子)。对于一个二进制表示$i$来说，我们需要求出它的个数与，它补集的子集个数的乘积，这即是求出了$gcd$为$1$的情况，对于不为$1$的情况，我们求出它与，它的补集对某一位$0$取反变成$1$的所有子集个数在减去它补集没去反之间子集的个数，这二者乘积，对所有的状态进行累加。\n 关键是如何快速求子集个数，对于$i$，求所有的$j$，$j\\leq i \u0026amp;\u0026amp;(i|j)==i$。网上代码为：\nfor(i=0;i\u0026lt;M;i++){ for(j=i;;j=(j-1)\u0026amp;i){ //s[i]为i的子集的个数，子集j对应的个数为num[j]  s[i]+=num[j]; //关键，得到子集  if(!j) break; } } 代码 #include \u0026lt;algorithm\u0026gt;#include \u0026lt;cmath\u0026gt;#include \u0026lt;cstdio\u0026gt;#include \u0026lt;cstring\u0026gt;#include \u0026lt;iostream\u0026gt;#include \u0026lt;map\u0026gt;#include \u0026lt;ostream\u0026gt;#include \u0026lt;queue\u0026gt;#include \u0026lt;set\u0026gt;#include \u0026lt;stack\u0026gt;#include \u0026lt;string\u0026gt;#include \u0026lt;unordered_map\u0026gt;#include \u0026lt;vector\u0026gt; #define INF 0x7f7f7f7f #define MAXN 100005 #define N 200005 #define MOD 1000000007 #define P 2  typedef long long ll; namespace fastIO { //#define getchar() (p1 == p2 \u0026amp;\u0026amp; (p2 = (p1 = buf) + fread(buf, 1, 1\u0026lt;\u0026lt;22, stdin),  // p1 == p2) ? EOF : *p1++) char buf[(1 \u0026lt;\u0026lt; 22)], *p1 = buf, *p2 = buf;  inline int read() { char c = getchar(); int x = 0, f = 1; while (c \u0026lt; \u0026#39;0\u0026#39; || c \u0026gt; \u0026#39;9\u0026#39;) { if (c == \u0026#39;-\u0026#39;) f = -1; c = getchar(); } while (c \u0026gt;= \u0026#39;0\u0026#39; \u0026amp;\u0026amp; c \u0026lt;= \u0026#39;9\u0026#39;) x = x * 10 + c - \u0026#39;0\u0026#39;, c = getchar(); return x * f; } } // namespace fastIO  using namespace fastIO; using namespace std; const int M = 1 \u0026lt;\u0026lt; 15; int t, n, a[M], b[M], p[16] = {2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47}; //2,3,5,7,11,13,17,19,23,29,31,37,41,43,47 int main() { cin \u0026gt;\u0026gt; t; while (t--) { memset(a, 0, sizeof(a)); memset(b, 0, sizeof(b)); cin \u0026gt;\u0026gt; n; ll x; for (int i = 1; i \u0026lt;= n; i++) { cin \u0026gt;\u0026gt; x; int temp = 0; for (int j = 0; j \u0026lt; 15; j++) if (x % p[j] == 0) temp += (1 \u0026lt;\u0026lt; j); //x为1时，temp为0  a[temp]++; } for (int i = 0; i \u0026lt; M; i++) //枚举j二进制表示下的子集  for (int j = i;;j = (j - 1)\u0026amp; i) { b[i] += a[j]; //写在这里，是考虑特殊情况，比如输入的x为1  if (!j) break; } ll ans = 0; for (int i = 0; i \u0026lt; M; i++) { //gcd为1  ans += 1ll * a[i] * b[i ^ (M - 1)]; //gcd为一个素数  for (int j = 0; j \u0026lt; 15; j++) if ((i \u0026gt;\u0026gt; j) \u0026amp; 1) ans += 1ll * a[i] * (b[i ^ (M - 1) ^ (1 \u0026lt;\u0026lt; j)] - b[i ^ (M - 1)]); } cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl; } } ","date":"2019-09-25T17:24:45Z","permalink":"https://chagelo.github.io/hugo/post/spoj-no-gcd/","section":"post","tags":["数学","思维"],"title":"[SPOJ NO GCD]"},{"categories":null,"contents":"","date":"2019-05-28T00:00:00Z","permalink":"https://chagelo.github.io/hugo/archives/","section":"","tags":null,"title":""},{"categories":["themes","syntax"],"contents":"This article offers a sample of basic Markdown syntax that can be used in Hugo content files, also it shows whether basic HTML elements are decorated with CSS in a Hugo theme.\nHeadings The following HTML \u0026lt;h1\u0026gt;—\u0026lt;h6\u0026gt; elements represent six levels of section headings. \u0026lt;h1\u0026gt; is the highest section level while \u0026lt;h6\u0026gt; is the lowest.\nH1 H2 H3 H4 H5 H6 Paragraph Xerum, quo qui aut unt expliquam qui dolut labo. Aque venitatiusda cum, voluptionse latur sitiae dolessi aut parist aut dollo enim qui voluptate ma dolestendit peritin re plis aut quas inctum laceat est volestemque commosa as cus endigna tectur, offic to cor sequas etum rerum idem sintibus eiur? Quianimin porecus evelectur, cum que nis nust voloribus ratem aut omnimi, sitatur? Quiatem. Nam, omnis sum am facea corem alique molestrunt et eos evelece arcillit ut aut eos eos nus, sin conecerem erum fuga. Ri oditatquam, ad quibus unda veliamenimin cusam et facea ipsamus es exerum sitate dolores editium rerore eost, temped molorro ratiae volorro te reribus dolorer sperchicium faceata tiustia prat.\nItatur? Quiatae cullecum rem ent aut odis in re eossequodi nonsequ idebis ne sapicia is sinveli squiatum, core et que aut hariosam ex eat.\nBlockquotes The blockquote element represents content that is quoted from another source, optionally with a citation which must be within a footer or cite element, and optionally with in-line changes such as annotations and abbreviations.\nBlockquote without attribution  Tiam, ad mint andaepu dandae nostion secatur sequo quae. Note that you can use Markdown syntax within a blockquote.\n Blockquote with attribution  Don\u0026rsquo;t communicate by sharing memory, share memory by communicating.\n— Rob Pike1\n Tables Tables aren\u0026rsquo;t part of the core Markdown spec, but Hugo supports supports them out-of-the-box.\n   Name Age     Bob 27   Alice 23    Inline Markdown within tables    Inline  Markdown  In  Table     italics bold strikethrough  code    Code Blocks Code block with backticks html \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026quot;en\u0026quot;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026quot;UTF-8\u0026quot;\u0026gt; \u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Code block indented with four spaces \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026quot;en\u0026quot;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026quot;UTF-8\u0026quot;\u0026gt; \u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt;  Code block with Hugo\u0026rsquo;s internal highlight shortcode \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; List Types Ordered List  First item Second item Third item  Unordered List  List item Another item And another item  Nested list  Item   First Sub-item Second Sub-item  Other Elements — abbr, sub, sup, kbd, mark GIF is a bitmap image format.\nH2O\nXn + Yn = Zn\nPress CTRL+ALT+Delete to end the session.\nMost salamanders are nocturnal, and hunt for insects, worms, and other small creatures.\n  The above quote is excerpted from Rob Pike\u0026rsquo;s talk during Gopherfest, November 18, 2015.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n  ","date":"2019-03-11T00:00:00Z","permalink":"https://chagelo.github.io/hugo/post/markdown-syntax/","section":"post","tags":["markdown","css","html","themes"],"title":"Markdown Syntax Guide"},{"categories":null,"contents":"Lorem est tota propiore conpellat pectoribus de pectora summo.\nRedit teque digerit hominumque toris verebor lumina non cervice subde tollit usus habet Arctonque, furores quas nec ferunt. Quoque montibus nunc caluere tempus inhospita parcite confusaque translucet patri vestro qui optatis lumine cognoscere flos nubis! Fronde ipsamque patulos Dryopen deorum.\n Exierant elisi ambit vivere dedere Duce pollice Eris modo Spargitque ferrea quos palude  Rursus nulli murmur; hastile inridet ut ab gravi sententia! Nomine potitus silentia flumen, sustinet placuit petis in dilapsa erat sunt. Atria tractus malis.\n Comas hunc haec pietate fetum procerum dixit Post torum vates letum Tiresia Flumen querellas Arcanaque montibus omnes Quidem et  Vagus elidunt \nThe Van de Graaf Canon\nMane refeci capiebant unda mulcebat Victa caducifer, malo vulnere contra dicere aurato, ludit regale, voca! Retorsit colit est profanae esse virescere furit nec; iaculi matertera et visa est, viribus. Divesque creatis, tecta novat collumque vulnus est, parvas. Faces illo pepulere tempus adest. Tendit flamma, ab opes virum sustinet, sidus sequendo urbis.\nIubar proles corpore raptos vero auctor imperium; sed et huic: manus caeli Lelegas tu lux. Verbis obstitit intus oblectamina fixis linguisque ausus sperare Echionides cornuaque tenent clausit possit. Omnia putatur. Praeteritae refert ausus; ferebant e primus lora nutat, vici quae mea ipse. Et iter nil spectatae vulnus haerentia iuste et exercebat, sui et.\nEurytus Hector, materna ipsumque ut Politen, nec, nate, ignari, vernum cohaesit sequitur. Vel mitis temploque vocatus, inque alis, oculos nomen non silvis corpore coniunx ne displicet illa. Crescunt non unus, vidit visa quantum inmiti flumina mortis facto sic: undique a alios vincula sunt iactata abdita! Suspenderat ego fuit tendit: luna, ante urbem Propoetides parte.\n .canon { background: white; width: 100%; height: auto;} ","date":"2019-03-09T00:00:00Z","permalink":"https://chagelo.github.io/hugo/post/placeholder-text/","section":"post","tags":["markdown","text"],"title":"Placeholder Text"},{"categories":null,"contents":"Emoji can be enabled in a Hugo project in a number of ways.\nThe emojify function can be called directly in templates or Inline Shortcodes.\nTo enable emoji globally, set enableEmoji to true in your site’s configuration and then you can type emoji shorthand codes directly in content files; e.g.\n🙈 :see_no_evil: 🙉 :hear_no_evil: 🙊 :speak_no_evil:\nThe Emoji cheat sheet is a useful reference for emoji shorthand codes.\n N.B. The above steps enable Unicode Standard emoji characters and sequences in Hugo, however the rendering of these glyphs depends on the browser and the platform. To style the emoji you can either use a third party emoji font or a font stack; e.g.\n.emoji { font-family: Apple Color Emoji,Segoe UI Emoji,NotoColorEmoji,Segoe UI Symbol,Android Emoji,EmojiSymbols; }  .emojify { font-family: Apple Color Emoji,Segoe UI Emoji,NotoColorEmoji,Segoe UI Symbol,Android Emoji,EmojiSymbols; font-size: 2rem; vertical-align: middle; } @media screen and (max-width:650px) { .nowrap { display: block; margin: 25px 0; } } ","date":"2019-03-05T00:00:00Z","permalink":"https://chagelo.github.io/hugo/post/emoji-support/","section":"post","tags":["emoji"],"title":"Emoji Support"},{"categories":null,"contents":"Written in Go, Hugo is an open source static site generator available under the Apache Licence 2.0. Hugo supports TOML, YAML and JSON data file types, Markdown and HTML content files and uses shortcodes to add rich content. Other notable features are taxonomies, multilingual mode, image processing, custom output formats, HTML/CSS/JS minification and support for Sass SCSS workflows.\nHugo makes use of a variety of open source projects including:\n https://github.com/yuin/goldmark https://github.com/alecthomas/chroma https://github.com/muesli/smartcrop https://github.com/spf13/cobra https://github.com/spf13/viper  Hugo is ideal for blogs, corporate websites, creative portfolios, online magazines, single page applications or even a website with thousands of pages.\nHugo is for people who want to hand code their own website without worrying about setting up complicated runtimes, dependencies and databases.\nWebsites built with Hugo are extremelly fast, secure and can be deployed anywhere including, AWS, GitHub Pages, Heroku, Netlify and any other hosting provider.\nLearn more and contribute on GitHub.\n","date":"2019-02-28T00:00:00Z","permalink":"https://chagelo.github.io/hugo/about/","section":"","tags":null,"title":"About"}]